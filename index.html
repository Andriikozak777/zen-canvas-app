<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Дзен-Холст: Максимально Улучшенная Версия</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Основные стили для тела страницы (темная тема по умолчанию) */
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            color: white;
            background-color: #000;
            position: relative;
            cursor: default;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* Стили для холста */
        canvas {
            display: block;
            background-color: #000;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
            transition: background-color 0.5s ease;
        }

        /* Наложение для затемнения и текста */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            text-align: center;
            z-index: 10;
            opacity: 1;
            transition: opacity 1.5s ease-out, background-color 0.5s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Стили для заголовка и текста в оверлее */
        .overlay h1, .overlay p {
            color: white;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: color 0.5s ease, text-shadow 0.5s ease;
        }

        /* Стили для кнопки "Старт" */
        .start-button {
            background-color: #4CAF50;
            color: white;
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 0.75rem;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .start-button:hover {
            background-color: #45a049;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        .start-button:active {
            background-color: #3e8e41;
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Стили для панели управления (теперь это боковое меню) */
        .controls-panel {
            position: fixed; /* Фиксированное позиционирование */
            top: 0;
            left: 0;
            height: 100vh; /* Полная высота экрана */
            width: 320px; /* Ширина меню */
            max-width: 80vw; /* Максимальная ширина на мобильных */
            background: rgba(45, 55, 72, 0.9); /* Более плотный фон для меню */
            backdrop-filter: blur(10px); /* Усиленный эффект размытия */
            -webkit-backdrop-filter: blur(10px);
            padding-top: 4rem; /* Увеличенный отступ сверху для избежания перекрытия */
            padding-bottom: 1.8rem;
            padding-left: 1.8rem;
            padding-right: 1.8rem;
            border-radius: 0 1.2rem 1.2rem 0; /* Скругление только справа */
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            border-right: 1px solid rgba(100, 116, 139, 0.3); /* Граница справа */
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            transform: translateX(-100%); /* Изначально скрыто слева */
            transition: transform 0.3s ease-in-out, background-color 0.5s ease, border-color 0.5s ease;
            overflow-y: auto; /* Прокрутка для содержимого */
        }

        .controls-panel.visible {
            transform: translateX(0); /* Выдвигается на экран */
        }

        /* Стилизация полосы прокрутки для Webkit-браузеров */
        .controls-panel::-webkit-scrollbar {
            width: 8px;
        }

        .controls-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .controls-panel::-webkit-scrollbar-thumb {
            background: #63b3ed;
            border-radius: 10px;
            transition: background 0.3s ease;
        }

        .controls-panel::-webkit-scrollbar-thumb:hover {
            background: #4299e1;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            align-items: flex-start;
        }

        .control-group label {
            font-size: 1.05rem;
            color: #e2e8f0;
            font-weight: bold;
            margin-bottom: 0.15rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: color 0.5s ease, text-shadow 0.5s ease;
        }

        /* Стили для ползунков (input[type="range"]) */
        .control-group input[type="range"] {
            width: 100%;
            height: 12px;
            background: linear-gradient(to right, #63b3ed, #4299e1);
            outline: none;
            border-radius: 6px;
            opacity: 0.95;
            transition: opacity .2s, box-shadow .2s, background 0.5s ease;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.4);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none;
        }

        .control-group input[type="range"]:hover {
            opacity: 1;
            box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.5);
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #a0aec0;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
            border: 3px solid #4299e1;
            transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, border-color 0.5s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #cbd5e0;
            transform: scale(1.15);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #a0aec0;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
            border: 3px solid #4299e1;
            transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, border-color 0.5s ease;
        }
        .control-group input[type="range"]::-moz-range-thumb:hover {
            background: #cbd5e0;
            transform: scale(1.15);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.5);
        }

        /* Стили для выпадающих списков (select) */
        .control-group select {
            width: 100%;
            height: 42px;
            background: #cbd5e0;
            outline: none;
            border-radius: 6px;
            opacity: 0.95;
            transition: opacity .2s, box-shadow .2s, background 0.5s ease, color 0.5s ease;
            color: #333;
            border: none;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23333333%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.6-6.4H19.4a17.6%2017.6%200%200%200-13.6%206.4%2017.6%2017.6%200%200%200%200%2025.3l128%20128a17.6%2017.6%200%200%200%2025.3%200l128-128c6.5-6.4%206.5-17.6%200-25.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7em center;
            background-size: 0.9em auto;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.4);
        }
        .control-group select:hover {
            opacity: 1;
            box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.5);
        }

        /* Стили для кнопки меню/скрытия */
        .menu-toggle-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: linear-gradient(145deg, #63b3ed, #4299e1);
            color: white;
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 0.6rem;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease, color 0.5s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            z-index: 21;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .menu-toggle-button:hover {
            background: linear-gradient(145deg, #4299e1, #3182ce);
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.4);
        }

        .menu-toggle-button:active {
            background: linear-gradient(145deg, #3182ce, #2b6cb0);
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Стили для кнопок действий (Очистить, Сбросить, Скриншот) */
        .action-button {
            background: linear-gradient(145deg, #e53e3e, #c53030);
            color: white;
            padding: 0.9rem 1.8rem;
            border: none;
            border-radius: 0.8rem;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease, color 0.5s ease;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
            margin-top: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .action-button:hover {
            background: linear-gradient(145deg, #c53030, #9b2c2c);
            transform: translateY(-3px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.4);
        }

        .action-button:active {
            background: linear-gradient(145deg, #9b2c2c, #7b1e1e);
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Стиль для кнопки сброса (отличный цвет) */
        .reset-button {
            background: linear-gradient(145deg, #f6e05e, #ecc94b);
            color: #333;
        }
        .reset-button:hover {
            background: linear-gradient(145deg, #ecc94b, #d69e2e);
            color: #222;
        }
        .reset-button:active {
            background: linear-gradient(145deg, #d69e2e, #b7791f);
            color: #111;
        }

        /* Стиль для кнопки скриншота */
        .screenshot-button {
            background: linear-gradient(145deg, #81e6d9, #4fd1c5);
            color: #333;
        }
        .screenshot-button:hover {
            background: linear-gradient(145deg, #4fd1c5, #38b2ac);
            color: #222;
        }
        .screenshot-button:active {
            background: linear-gradient(145deg, #38b2ac, #319795);
            color: #111;
        }

        /* --- Стили для кнопки переключения темы --- */
        .theme-toggle-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: linear-gradient(145deg, #a0aec0, #cbd5e0); /* Светлый градиент */
            color: #333; /* Темный текст */
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 0.6rem;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease, color 0.5s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            z-index: 21;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .theme-toggle-button:hover {
            background: linear-gradient(145deg, #cbd5e0, #e2e8f0);
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.4);
        }

        .theme-toggle-button:active {
            background: linear-gradient(145deg, #e2e8f0, #edf2f7);
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* --- Стили для БЭКДРОПА меню --- */
        .menu-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Полупрозрачный черный */
            z-index: 19; /* Под меню, но над холстом */
            opacity: 0;
            pointer-events: none; /* Не реагирует на события, пока скрыт */
            transition: opacity 0.3s ease-in-out;
        }

        .menu-backdrop.visible {
            opacity: 1;
            pointer-events: auto; /* Реагирует на события, когда видим */
        }

        /* Стили для инструкций в панели управления */
        #gameInstructions {
            font-size: 0.9rem;
            color: #a0aec0;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
            border-radius: 0.5rem;
            line-height: 1.4;
            margin-top: 0.5rem;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* --- Стили для СВЕТЛОЙ ТЕМЫ --- */
        body.light-theme {
            background-color: #f0f0f0;
            color: #333;
        }

        body.light-theme canvas {
            background-color: #e0e0e0;
        }

        body.light-theme .overlay {
            background-color: rgba(255, 255, 255, 0.8);
        }

        body.light-theme .overlay h1, body.light-theme .overlay p {
            color: #333;
            text-shadow: none;
        }

        body.light-theme .controls-panel {
            background: rgba(255, 255, 255, 0.9);
            border-right: 1px solid rgba(0, 0, 0, 0.2);
        }

        body.light-theme .controls-panel::-webkit-scrollbar-track {
            background: rgba(200, 200, 200, 0.5);
        }

        body.light-theme .controls-panel::-webkit-scrollbar-thumb {
            background: #a0aec0;
        }

        body.light-theme .control-group label {
            color: #333;
            text-shadow: none;
        }

        body.light-theme .control-group input[type="range"] {
            background: linear-gradient(to right, #cbd5e0, #e2e8f0);
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        body.light-theme .control-group input[type="range"]::-webkit-slider-thumb {
            background: #4299e1;
            border-color: #63b3ed;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        body.light-theme .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #3182ce;
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        body.light-theme .control-group input[type="range"]::-moz-range-thumb {
            background: #4299e1;
            border-color: #63b3ed;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        body.light-theme .control-group input[type="range"]::-moz-range-thumb:hover {
            background: #3182ce;
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        body.light-theme .control-group select {
            background: #e2e8f0;
            color: #333;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.6-6.4H19.4a17.6%2017.6%200%200%200-13.6%206.4%2017.6%2017.6%200%200%200%200%2025.3l128%20128a17.6%2017.6%200%200%200%2025.3%200l128-128c6.5-6.4%206.5-17.6%200-25.3z%22%2F%3E%3C%2Fsvg%3E');
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.2);
        }
        body.light-theme .control-group select:hover {
            box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.3);
        }

        body.light-theme .menu-toggle-button {
            background: linear-gradient(145deg, #a0aec0, #cbd5e0);
            color: #333;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        body.light-theme .menu-toggle-button:hover {
            background: linear-gradient(145deg, #cbd5e0, #e2e8f0);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }
        body.light-theme .menu-toggle-button:active {
            background: linear-gradient(145deg, #e2e8f0, #edf2f7);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .action-button {
            background: linear-gradient(145deg, #63b3ed, #4299e1);
            color: white;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }
        body.light-theme .action-button:hover {
            background: linear-gradient(145deg, #4299e1, #3182ce);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.3);
        }
        body.light-theme .action-button:active {
            background: linear-gradient(145deg, #3182ce, #2b6cb0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .reset-button {
            background: linear-gradient(145deg, #f6e05e, #ecc94b);
            color: #333;
        }
        body.light-theme .reset-button:hover {
            background: linear-gradient(145deg, #ecc94b, #d69e2e);
            color: #222;
        }
        body.light-theme .reset-button:active {
            background: linear-gradient(145deg, #d69e2e, #b7791f);
            color: #111;
        }

        body.light-theme .screenshot-button {
            background: linear-gradient(145deg, #81e6d9, #4fd1c5);
            color: #333;
        }
        body.light-theme .screenshot-button:hover {
            background: linear-gradient(145deg, #4fd1c5, #38b2ac);
            color: #222;
        }
        body.light-theme .screenshot-button:active {
            background: linear-gradient(145deg, #38b2ac, #319795);
            color: #111;
        }

        body.light-theme #gameInstructions {
            color: #333;
            background-color: rgba(200, 200, 200, 0.5);
        }

        /* Медиа-запросы для адаптации на мобильных устройствах */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            p {
                font-size: 1rem;
                max-width: 90%;
            }
            .start-button {
                font-size: 1.1rem;
                padding: 0.8rem 2rem;
            }
            .controls-panel {
                width: 90vw; /* Большая часть экрана */
                padding-top: 3rem; /* Увеличенный отступ сверху на мобильных */
                padding-bottom: 1rem;
                padding-left: 1rem;
                padding-right: 1rem;
                border-radius: 0 0 1.2rem 0; /* Скругление только снизу справа */
            }
            .control-group {
                flex-direction: column; /* Вертикальное расположение на мобильных */
                align-items: flex-start;
                gap: 0.3rem;
            }
            .control-group label {
                font-size: 0.9rem;
            }
            .control-group input[type="range"],
            .control-group select {
                width: 100%; /* Полная ширина на мобильных */
                height: 8px;
            }
            .menu-toggle-button {
                top: 0.5rem;
                left: 0.5rem;
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            .action-button {
                padding: 0.6rem 1.2rem;
                font-size: 0.95rem;
            }
            .theme-toggle-button {
                top: 0.5rem;
                right: 0.5rem;
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            #gameInstructions {
                font-size: 0.8rem;
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="artCanvas"></canvas>
    <div class="overlay" id="overlay">
        <h1 id="overlayTitle">Дзен-Холст</h1>
        <p id="overlayText">Нажмите "Старт", чтобы начать медитативную мелодию и творить визуальное искусство.</p>
        <button id="startButton" class="start-button">Старт</button>
    </div>

    <div class="controls-panel" id="controlsPanel">
        <div class="control-group">
            <label for="languageSelect" id="languageLabel">Язык:</label>
            <select id="languageSelect">
                <option value="ru">Русский</option>
                <option value="uk">Українська</option>
                <option value="en">English</option>
            </select>
        </div>
        <div class="control-group">
            <label for="gameModeSelect" id="gameModeLabel">Режим игры:</label>
            <select id="gameModeSelect">
                <option value="free-play" id="freePlayOption">Свободная игра</option>
                <option value="echo-sphere" id="echoSphereOption">Эхо-сфера</option>
                <option value="melody-maze" id="melodyMazeOption">Мелодичный лабиринт</option>
            </select>
        </div>
        <div id="gameInstructions">
            </div>
        <div class="control-group">
            <label for="volumeSlider" id="volumeLabel">Громкость:</label>
            <input type="range" id="volumeSlider" min="-30" max="0" value="-10" step="1">
        </div>
        <div class="control-group">
            <label for="particleMinSizeSlider" id="particleMinSizeLabel">Мин. размер частиц:</label>
            <input type="range" id="particleMinSizeSlider" min="0.5" max="5" value="2" step="0.1">
        </div>
        <div class="control-group">
            <label for="particleMaxSizeSlider" id="particleMaxSizeLabel">Макс. размер частиц:</label>
            <input type="range" id="particleMaxSizeSlider" min="1" max="10" value="8" step="0.1">
        </div>
        <div class="control-group">
            <label for="particleLifeSlider" id="particleLifeLabel">Время жизни частиц:</label>
            <input type="range" id="particleLifeSlider" min="50" max="300" value="150" step="10">
        </div>
        <div class="control-group">
            <label for="particleSpeedSlider" id="particleSpeedLabel">Скорость частиц:</label>
            <input type="range" id="particleSpeedSlider" min="0.5" max="5" value="3" step="0.1">
        </div>
        <div class="control-group">
            <label for="particleCountSlider" id="particleCountLabel">Кол-во частиц:</label>
            <input type="range" id="particleCountSlider" min="100" max="800" value="400" step="50">
        </div>
        <div class="control-group">
            <label for="particleSpawnRateSlider" id="particleSpawnRateLabel">Частота частиц:</label>
            <input type="range" id="particleSpawnRateSlider" min="1" max="10" value="2" step="1">
        </div>
        <div class="control-group">
            <label for="melodyTempoSlider" id="melodyTempoLabel">Темп мелодии:</label>
            <input type="range" id="melodyTempoSlider" min="60" max="180" value="120" step="5">
        </div>
        <div class="control-group">
            <label for="colorPaletteSelect" id="colorPaletteLabel">Палитра:</label>
            <select id="colorPaletteSelect">
                <option value="dynamic" id="dynamicPaletteOption">Динамическая (Радуга)</option>
                <option value="warm" id="warmPaletteOption">Теплая (Красные/Оранжевые)</option>
                <option value="cool" id="coolPaletteOption">Холодная (Синие/Зеленые)</option>
                <option value="pastel" id="pastelPaletteOption">Пастельная</option>
                <option value="vibrant" id="vibrantPaletteOption">Яркая</option>
            </select>
        </div>
        <div class="control-group">
            <label for="particleShapeSelect" id="particleShapeLabel">Форма частиц:</label>
            <select id="particleShapeSelect">
                <option value="circle" id="circleShapeOption">Круг</option>
                <option value="square" id="squareShapeOption">Квадрат</option>
                <option value="triangle" id="triangleShapeOption">Треугольник</option>
            </select>
        </div>
        <div class="control-group">
            <label for="particleMovementSelect" id="particleMovementLabel">Движение частиц:</label>
            <select id="particleMovementSelect">
                <option value="random" id="randomMovementOption">Случайное</option>
                <option value="spiral" id="spiralMovementOption">Спираль</option>
                <option value="wave" id="waveMovementOption">Волна</option>
            </select>
        </div>
        <div class="control-group">
            <label for="instrumentSelect" id="instrumentLabel">Инструмент:</label>
            <select id="instrumentSelect">
                <option value="simple-poly" id="simplePolyInstrumentOption">Пианино (по умолчанию)</option>
                <option value="fmsynth" id="fmsynthInstrumentOption">FM-синтезатор</option>
                <option value="amsynth" id="amsynthInstrumentOption">AM-синтезатор</option>
                <option value="pluck" id="pluckInstrumentOption">Плюк-синтезатор</option>
            </select>
        </div>
        <button id="clearCanvasButton" class="action-button">Очистить холст</button>
        <button id="screenshotButton" class="action-button screenshot-button">Сделать скриншот</button>
        <button id="resetSettingsButton" class="action-button reset-button">Сбросить настройки</button>
    </div>
    <button id="menuToggleButton" class="menu-toggle-button">☰ Меню</button>
    <button id="themeToggleButton" class="theme-toggle-button">Светлая тема</button>
    <div id="menuBackdrop" class="menu-backdrop"></div> 
    <script>
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const startButton = document.getElementById('startButton');
        const controlsPanel = document.getElementById('controlsPanel');
        const menuToggleButton = document.getElementById('menuToggleButton'); 
        const themeToggleButton = document.getElementById('themeToggleButton');
        const menuBackdrop = document.getElementById('menuBackdrop'); 

        // Элементы управления
        const languageSelect = document.getElementById('languageSelect'); // Новый элемент
        const volumeSlider = document.getElementById('volumeSlider');
        const particleMinSizeSlider = document.getElementById('particleMinSizeSlider');
        const particleMaxSizeSlider = document.getElementById('particleMaxSizeSlider');
        const particleLifeSlider = document.getElementById('particleLifeSlider');
        const particleSpeedSlider = document.getElementById('particleSpeedSlider');
        const particleCountSlider = document.getElementById('particleCountSlider');
        const particleSpawnRateSlider = document.getElementById('particleSpawnRateSlider');
        const melodyTempoSlider = document.getElementById('melodyTempoSlider'); 
        const colorPaletteSelect = document.getElementById('colorPaletteSelect');
        const particleShapeSelect = document.getElementById('particleShapeSelect');
        const particleMovementSelect = document.getElementById('particleMovementSelect');
        const instrumentSelect = document.getElementById('instrumentSelect');
        const clearCanvasButton = document.getElementById('clearCanvasButton');
        const screenshotButton = document.getElementById('screenshotButton');
        const resetSettingsButton = document.getElementById('resetSettingsButton');

        // Новые элементы для режима игры
        const gameModeSelect = document.getElementById('gameModeSelect');
        const gameInstructions = document.getElementById('gameInstructions');

        // --- Настройки по умолчанию (для кнопки сброса) ---
        const defaultSettings = {
            volume: -10,
            particleMinSize: 2, 
            particleMaxSize: 8, 
            particleLife: 150,
            particleSpeed: 3,
            particleCount: 400,
            particleSpawnRate: 2,
            melodyTempo: 120,
            colorPalette: 'dynamic',
            particleShape: 'circle',
            particleMovement: 'random',
            instrument: 'simple-poly',
            theme: 'dark',
            gameMode: 'free-play', // Добавлен режим игры по умолчанию
            language: 'ru' // Язык по умолчанию
        };

        // Цветовые палитры (HSL значения)
        const colorPalettes = {
            dynamic: [], 
            warm: [
                { h: 0, s: 70, l: 50 }, { h: 30, s: 70, l: 50 }, { h: 60, s: 70, l: 50 }
            ],
            cool: [
                { h: 180, s: 70, l: 50 }, { h: 210, s: 70, l: 50 }, { h: 240, s: 70, l: 50 }
            ],
            pastel: [
                { h: 300, s: 40, l: 70 }, { h: 120, s: 40, l: 70 }, { h: 240, s: 40, l: 70 }
            ],
            vibrant: [
                { h: 0, s: 90, l: 60 }, { h: 120, s: 90, l: 60 }, { h: 240, s: 90, l: 60 }, { h: 60, s: 90, l: 60 }
            ]
        };

        // --- Переменные состояния ---
        let particles = [];
        let maxParticles = parseInt(particleCountSlider.value);
        let particleBaseSpeed = parseFloat(particleSpeedSlider.value);
        let particleMinSize = parseFloat(particleMinSizeSlider.value);
        let particleMaxSize = parseFloat(particleMaxSizeSlider.value);
        let particleLife = parseInt(particleLifeSlider.value);
        let particleSpawnRate = defaultSettings.particleSpawnRate;
        let currentParticleShape = defaultSettings.particleShape;
        let currentColorPalette = defaultSettings.colorPalette;
        let currentParticleMovement = defaultSettings.particleMovement;
        let currentInstrument = defaultSettings.instrument;
        let hue = 0;
        let particlePulseFactor = 0;
        let audioAnalyzer;

        // Глобальные переменные для эффектов
        let reverb;
        let delay;

        // Текущая тема и режим игры
        let currentTheme = defaultSettings.theme;
        let gameMode = defaultSettings.gameMode; // Инициализация режима игры

        // Новые переменные для Melody Maze
        let currentMazePath = []; // Будет содержать масштабированные точки лабиринта
        const mazeLineTolerance = 50; // Насколько близко курсор должен быть к линии
        const mazeNotes = ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5"]; // Ноты для мелодии лабиринта (C Major Scale)
        let mazeSynth; // Синтезатор для мелодии лабиринта
        let mazeSequence; // Tone.Sequence для мелодии лабиринта
        let isMazePlayingAudio = false; // Отслеживание воспроизведения аудио лабиринта
        let synth; // Объявление synth здесь
        let loop; // Объявление loop здесь
        let interactionSynth; // Объявление interactionSynth здесь
        let isPlaying = false; // Флаг для основного игрового процесса (после нажатия "Старт")

        // --- Объект для переводов ---
        const translations = {
            ru: {
                overlayTitle: 'Дзен-Холст',
                overlayText: 'Нажмите "Старт", чтобы начать медитативную мелодию и творить визуальное искусство.',
                startButton: 'Старт',
                languageLabel: 'Язык:',
                gameModeLabel: 'Режим игры:',
                freePlayOption: 'Свободная игра',
                echoSphereOption: 'Эхо-сфера',
                melodyMazeOption: 'Мелодичный лабиринт',
                volumeLabel: 'Громкость:',
                particleMinSizeLabel: 'Мин. размер частиц:',
                particleMaxSizeLabel: 'Макс. размер частиц:',
                particleLifeLabel: 'Время жизни частиц:',
                particleSpeedLabel: 'Скорость частиц:',
                particleCountLabel: 'Кол-во частиц:',
                particleSpawnRateLabel: 'Частота частиц:',
                melodyTempoLabel: 'Темп мелодии:',
                colorPaletteLabel: 'Палитра:',
                dynamicPaletteOption: 'Динамическая (Радуга)',
                warmPaletteOption: 'Теплая (Красные/Оранжевые)',
                coolPaletteOption: 'Холодная (Синие/Зеленые)',
                pastelPaletteOption: 'Пастельная',
                vibrantPaletteOption: 'Яркая',
                particleShapeLabel: 'Форма частиц:',
                circleShapeOption: 'Круг',
                squareShapeOption: 'Квадрат',
                triangleShapeOption: 'Треугольник',
                particleMovementLabel: 'Движение частиц:',
                randomMovementOption: 'Случайное',
                spiralMovementOption: 'Спираль',
                waveMovementOption: 'Волна',
                instrumentLabel: 'Инструмент:',
                simplePolyInstrumentOption: 'Пианино (по умолчанию)',
                fmsynthInstrumentOption: 'FM-синтезатор',
                amsynthInstrumentOption: 'AM-синтезатор',
                pluckInstrumentOption: 'Плюк-синтезатор',
                clearCanvasButton: 'Очистить холст',
                screenshotButton: 'Сделать скриншот',
                resetSettingsButton: 'Сбросить настройки',
                menuButtonOpen: '☰ Меню',
                menuButtonClose: '✖ Закрыть',
                themeButtonLight: 'Светлая тема',
                themeButtonDark: 'Темная тема',
                freePlayInstructions: '<strong>Свободная игра:</strong> Двигайте мышью/пальцем, чтобы создавать частицы. Фоновая мелодия будет играть.',
                echoSphereInstructions: '<strong>Эхо-сфера:</strong> Нажмите и удерживайте мышь/палец, чтобы создать звуковую сферу. Отпустите, чтобы остановить.',
                melodyMazeInstructions: '<strong>Мелодичный лабиринт:</strong> Проведите мышью/пальцем вдоль синей линии, чтобы услышать мелодию. Новый лабиринт при каждом запуске!',
                selectGameModeInstructions: 'Выберите режим игры.',
                audioStartError: 'Не удалось запустить. Пожалуйста, попробуйте снова или проверьте настройки браузера.'
            },
            uk: {
                overlayTitle: 'Дзен-Полотно',
                overlayText: 'Натисніть "Старт", щоб розпочати медитативну мелодію та творити візуальне мистецтво.',
                startButton: 'Старт',
                languageLabel: 'Мова:',
                gameModeLabel: 'Режим гри:',
                freePlayOption: 'Вільна гра',
                echoSphereOption: 'Ехо-сфера',
                melodyMazeOption: 'Мелодійний лабіринт',
                volumeLabel: 'Гучність:',
                particleMinSizeLabel: 'Мін. розмір частинок:',
                particleMaxSizeLabel: 'Макс. розмір частинок:',
                particleLifeLabel: 'Час життя частинок:',
                particleSpeedLabel: 'Швидкість частинок:',
                particleCountLabel: 'Кількість частинок:',
                particleSpawnRateLabel: 'Частота частинок:',
                melodyTempoLabel: 'Темп мелодії:',
                colorPaletteLabel: 'Палітра:',
                dynamicPaletteOption: 'Динамічна (Веселка)',
                warmPaletteOption: 'Тепла (Червоні/Помаранчеві)',
                coolPaletteOption: 'Холодна (Сині/Зелені)',
                pastelPaletteOption: 'Пастельна',
                vibrantPaletteOption: 'Яскрава',
                particleShapeLabel: 'Форма частинок:',
                circleShapeOption: 'Коло',
                squareShapeOption: 'Квадрат',
                triangleShapeOption: 'Трикутник',
                particleMovementLabel: 'Рух частинок:',
                randomMovementOption: 'Випадковий',
                spiralMovementOption: 'Спіраль',
                waveMovementOption: 'Хвиля',
                instrumentLabel: 'Інструмент:',
                simplePolyInstrumentOption: 'Піаніно (за замовчуванням)',
                fmsynthInstrumentOption: 'FM-синтезатор',
                amsynthInstrumentOption: 'AM-синтезатор',
                pluckInstrumentOption: 'Плюк-синтезатор',
                clearCanvasButton: 'Очистити полотно',
                screenshotButton: 'Зробити знімок екрана',
                resetSettingsButton: 'Скинути налаштування',
                menuButtonOpen: '☰ Меню',
                menuButtonClose: '✖ Закрити',
                themeButtonLight: 'Світла тема',
                themeButtonDark: 'Темна тема',
                freePlayInstructions: '<strong>Вільна гра:</strong> Рухайте мишею/пальцем, щоб створювати частинки. Фонова мелодія гратиме.',
                echoSphereInstructions: '<strong>Ехо-сфера:</strong> Натисніть і утримуйте мишу/палець, щоб створити звукову сферу. Відпустіть, щоб зупинити.',
                melodyMazeInstructions: '<strong>Мелодійний лабіринт:</strong> Проведіть мишею/пальцем уздовж синьої лінії, щоб почути мелодію. Новий лабіринт при кожному запуску!',
                selectGameModeInstructions: 'Виберіть режим гри.',
                audioStartError: 'Не вдалося запустити. Будь ласка, спробуйте знову або перевірте налаштування браузера.'
            },
            en: {
                overlayTitle: 'Zen Canvas',
                overlayText: 'Click "Start" to begin a meditative melody and create visual art.',
                startButton: 'Start',
                languageLabel: 'Language:',
                gameModeLabel: 'Game Mode:',
                freePlayOption: 'Free Play',
                echoSphereOption: 'Echo Sphere',
                melodyMazeOption: 'Melody Maze',
                volumeLabel: 'Volume:',
                particleMinSizeLabel: 'Min Particle Size:',
                particleMaxSizeLabel: 'Max Particle Size:',
                particleLifeLabel: 'Particle Life:',
                particleSpeedLabel: 'Particle Speed:',
                particleCountLabel: 'Particle Count:',
                particleSpawnRateLabel: 'Particle Spawn Rate:',
                melodyTempoLabel: 'Melody Tempo:',
                colorPaletteLabel: 'Palette:',
                dynamicPaletteOption: 'Dynamic (Rainbow)',
                warmPaletteOption: 'Warm (Reds/Oranges)',
                coolPaletteOption: 'Cool (Blues/Greens)',
                pastelPaletteOption: 'Pastel',
                vibrantPaletteOption: 'Vibrant',
                particleShapeLabel: 'Particle Shape:',
                circleShapeOption: 'Circle',
                squareShapeOption: 'Square',
                triangleShapeOption: 'Triangle',
                particleMovementLabel: 'Particle Movement:',
                randomMovementOption: 'Random',
                spiralMovementOption: 'Spiral',
                waveMovementOption: 'Wave',
                instrumentLabel: 'Instrument:',
                simplePolyInstrumentOption: 'Piano (default)',
                fmsynthInstrumentOption: 'FM Synth',
                amsynthInstrumentOption: 'AM Synth',
                pluckInstrumentOption: 'Pluck Synth',
                clearCanvasButton: 'Clear Canvas',
                screenshotButton: 'Take Screenshot',
                resetSettingsButton: 'Reset Settings',
                menuButtonOpen: '☰ Menu',
                menuButtonClose: '✖ Close',
                themeButtonLight: 'Light Theme',
                themeButtonDark: 'Dark Theme',
                freePlayInstructions: '<strong>Free Play:</strong> Move your mouse/finger to create particles. A background melody will play.',
                echoSphereInstructions: '<strong>Echo Sphere:</strong> Press and hold your mouse/finger to create a sound sphere. Release to stop.',
                melodyMazeInstructions: '<strong>Melody Maze:</strong> Drag your mouse/finger along the blue line to hear a melody. A new maze each time!',
                selectGameModeInstructions: 'Select a game mode.',
                audioStartError: 'Failed to start. Please try again or check your browser settings.'
            }
        };

        let currentLanguage = defaultSettings.language; // Текущий язык

        // Функция для установки языка
        function setLanguage(langCode) {
            currentLanguage = langCode;
            document.documentElement.lang = langCode; // Устанавливаем атрибут lang для HTML

            const currentTranslation = translations[langCode];

            // Обновляем текст в оверлее
            document.getElementById('overlayTitle').textContent = currentTranslation.overlayTitle;
            document.getElementById('overlayText').textContent = currentTranslation.overlayText;
            document.getElementById('startButton').textContent = currentTranslation.startButton;

            // Обновляем текст в панели управления
            document.getElementById('languageLabel').textContent = currentTranslation.languageLabel;
            document.getElementById('gameModeLabel').textContent = currentTranslation.gameModeLabel;
            document.getElementById('freePlayOption').textContent = currentTranslation.freePlayOption;
            document.getElementById('echoSphereOption').textContent = currentTranslation.echoSphereOption;
            document.getElementById('melodyMazeOption').textContent = currentTranslation.melodyMazeOption;
            document.getElementById('volumeLabel').textContent = currentTranslation.volumeLabel;
            document.getElementById('particleMinSizeLabel').textContent = currentTranslation.particleMinSizeLabel;
            document.getElementById('particleMaxSizeLabel').textContent = currentTranslation.particleMaxSizeLabel;
            document.getElementById('particleLifeLabel').textContent = currentTranslation.particleLifeLabel;
            document.getElementById('particleSpeedLabel').textContent = currentTranslation.particleSpeedLabel;
            document.getElementById('particleCountLabel').textContent = currentTranslation.particleCountLabel;
            document.getElementById('particleSpawnRateLabel').textContent = currentTranslation.particleSpawnRateLabel;
            document.getElementById('melodyTempoLabel').textContent = currentTranslation.melodyTempoLabel;
            document.getElementById('colorPaletteLabel').textContent = currentTranslation.colorPaletteLabel;
            document.getElementById('dynamicPaletteOption').textContent = currentTranslation.dynamicPaletteOption;
            document.getElementById('warmPaletteOption').textContent = currentTranslation.warmPaletteOption;
            document.getElementById('coolPaletteOption').textContent = currentTranslation.coolPaletteOption;
            document.getElementById('pastelPaletteOption').textContent = currentTranslation.pastelPaletteOption;
            document.getElementById('vibrantPaletteOption').textContent = currentTranslation.vibrantPaletteOption;
            document.getElementById('particleShapeLabel').textContent = currentTranslation.particleShapeLabel;
            document.getElementById('circleShapeOption').textContent = currentTranslation.circleShapeOption;
            document.getElementById('squareShapeOption').textContent = currentTranslation.squareShapeOption;
            document.getElementById('triangleShapeOption').textContent = currentTranslation.triangleShapeOption;
            document.getElementById('particleMovementLabel').textContent = currentTranslation.particleMovementLabel;
            document.getElementById('randomMovementOption').textContent = currentTranslation.randomMovementOption;
            document.getElementById('spiralMovementOption').textContent = currentTranslation.spiralMovementOption;
            document.getElementById('waveMovementOption').textContent = currentTranslation.waveMovementOption;
            document.getElementById('instrumentLabel').textContent = currentTranslation.instrumentLabel;
            document.getElementById('simplePolyInstrumentOption').textContent = currentTranslation.simplePolyInstrumentOption;
            document.getElementById('fmsynthInstrumentOption').textContent = currentTranslation.fmsynthInstrumentOption;
            document.getElementById('amsynthInstrumentOption').textContent = currentTranslation.amsynthInstrumentOption;
            document.getElementById('pluckInstrumentOption').textContent = currentTranslation.pluckInstrumentOption;
            document.getElementById('clearCanvasButton').textContent = currentTranslation.clearCanvasButton;
            document.getElementById('screenshotButton').textContent = currentTranslation.screenshotButton;
            document.getElementById('resetSettingsButton').textContent = currentTranslation.resetSettingsButton;
            
            // Обновляем текст кнопки меню
            menuToggleButton.textContent = controlsPanel.classList.contains('visible') ? currentTranslation.menuButtonClose : currentTranslation.menuButtonOpen;
            
            // Обновляем текст кнопки темы
            themeToggleButton.textContent = currentTheme === 'dark' ? currentTranslation.themeButtonLight : currentTranslation.themeButtonDark;

            // Обновляем инструкции для игры
            updateGameInstructions();

            // Сохраняем выбранный язык
            localStorage.setItem('zenLanguage', langCode);
        }

        // --- Настройки холста ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Перегенерируем лабиринт при изменении размера холста
            if (gameMode === 'melody-maze') {
                generateRandomMazePath();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        // resizeCanvas(); // Вызов здесь не нужен, так как он будет вызван в window.onload

        // Function to update game instructions based on current game mode
        function updateGameInstructions() {
            const currentTranslation = translations[currentLanguage];
            switch (gameMode) {
                case 'free-play':
                    gameInstructions.innerHTML = currentTranslation.freePlayInstructions;
                    break;
                case 'echo-sphere':
                    gameInstructions.innerHTML = currentTranslation.echoSphereInstructions;
                    break;
                case 'melody-maze':
                    gameInstructions.innerHTML = currentTranslation.melodyMazeInstructions;
                    break;
                default:
                    gameInstructions.innerHTML = currentTranslation.selectGameModeInstructions;
            }
        }

        // Helper function to calculate distance from a point to a line segment
        function distToSegmentSquared(p, v, w) {
            const l2 = (w.x - v.x) * (w.x - v.x) + (w.y - v.y) * (w.y - v.y);
            if (l2 === 0) return (p.x - v.x) * (p.x - v.x) + (p.y - v.y) * (p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = {
                x: v.x + t * (w.x - v.x),
                y: v.y + t * (w.y - v.y)
            };
            return (p.x - projection.x) * (p.x - projection.x) + (p.y - projection.y) * (p.y - projection.y);
        }

        function distToSegment(p, v, w) {
            return Math.sqrt(distToSegmentSquared(p, v, w));
        }

        // Функция для генерации случайного пути лабиринта
        function generateRandomMazePath() {
            currentMazePath = [];
            const minX = 0.1; // Начало пути от 10% ширины
            const maxX = 0.9; // Конец пути до 90% ширины
            const minY = 0.1; // Верхняя граница пути
            const maxY = 0.9; // Нижняя граница пути
            const minSegmentLength = 0.05; // Минимальная длина сегмента
            const maxSegmentLength = 0.15; // Максимальная длина сегмента
            const maxAngleChange = Math.PI / 4; // Максимальное изменение угла (45 градусов)
            // const pathSmoothness = 0.5; // Фактор сглаживания пути (0-1, 0 - ломаная, 1 - прямая) // Не используется напрямую

            let currentX = minX;
            let currentY = Math.random() * (maxY - minY) + minY; // Случайная начальная Y
            let currentAngle = Math.random() * Math.PI / 2 - Math.PI / 4; // Начальный угол около горизонтального

            currentMazePath.push({ x: currentX * canvas.width, y: currentY * canvas.height });

            while (currentX < maxX) {
                // Случайное изменение угла
                currentAngle += (Math.random() - 0.5) * maxAngleChange * 2;
                // Ограничиваем угол, чтобы путь не уходил слишком сильно вверх/вниз
                currentAngle = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, currentAngle));

                const segmentLength = (Math.random() * (maxSegmentLength - minSegmentLength) + minSegmentLength);
                
                let nextX = currentX + Math.cos(currentAngle) * segmentLength;
                let nextY = currentY + Math.sin(currentAngle) * segmentLength;

                // Корректировка, чтобы путь оставался в пределах холста
                nextX = Math.max(minX, Math.min(maxX, nextX));
                nextY = Math.max(minY, Math.min(maxY, nextY));

                currentMazePath.push({ x: nextX * canvas.width, y: nextY * canvas.height });

                currentX = nextX;
                currentY = nextY;
            }
            // Убедимся, что последняя точка достигает правой границы
            currentMazePath[currentMazePath.length - 1].x = maxX * canvas.width;
        }


        // Функция для отрисовки частицы в зависимости от выбранной формы
        function drawParticle(p) {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha;

            switch (currentParticleShape) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); 
                    ctx.fill();
                    break;
                case 'square':
                    const size = p.radius * 2; 
                    ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
                    break;
                case 'triangle':
                    const triHeight = p.radius * 2 * (Math.sqrt(3) / 2); 
                    const triBase = p.radius * 2; 
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y - triHeight / 2);
                    ctx.lineTo(p.x - triBase / 2, p.y + triHeight / 2);
                    ctx.lineTo(p.x + triBase / 2, p.y + triHeight / 2);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
        }

        // Функция для получения цвета частицы из палитры
        function getParticleColor() {
            const lightness = currentTheme === 'light' ? 70 : 50;
            if (currentColorPalette === 'dynamic') {
                return `hsl(${hue}, 70%, ${lightness}%)`;
            } else {
                const palette = colorPalettes[currentColorPalette];
                const colorIndex = Math.floor(Math.random() * palette.length);
                const color = palette[colorIndex];
                return `hsl(${color.h}, ${color.s}%, ${color.l}%)`; 
            }
        }

        // Tone.js Synth для звуков взаимодействия (теперь используется для "Эхо-сферы")
        let activeEchoSynthNote = null; // Для отслеживания удерживаемой ноты в режиме "Эхо-сфера"

        function createParticle(x, y) {
            const baseRadius = Math.random() * (particleMaxSize - particleMinSize) + particleMinSize;
            const radius = baseRadius + particlePulseFactor * 2;
            let speedX = (Math.random() - 0.5) * particleBaseSpeed;
            let speedY = (Math.random() - 0.5) * particleBaseSpeed;

            // Логика создания частиц в зависимости от режима игры
            if (gameMode === 'echo-sphere') {
                const angle = Math.random() * Math.PI * 2; // Случайный угол для радиального разлета
                particles.push({
                    x: x, 
                    y: y, 
                    initialX: x, // Начальная позиция для расчета разлета
                    initialY: y,
                    angle: angle, // Угол разлета
                    radius: radius * 0.5, // Начинаем с меньшего радиуса
                    color: getParticleColor(),
                    alpha: 1,
                    speedX: Math.cos(angle) * (particleBaseSpeed * 1.5), // Начальная скорость разлета
                    speedY: Math.sin(angle) * (particleBaseSpeed * 1.5),
                    life: particleLife * 3, // Увеличенное время жизни для эффекта сферы
                    spawnTime: Tone.now() // Время создания частицы
                });
                return; // Выходим, так как частица уже добавлена
            }

            // Существующая логика для свободной игры и других движений
            if (currentParticleMovement === 'spiral') {
                const angle = Math.atan2(y - canvas.height / 2, x - canvas.width / 2);
                const distance = Math.sqrt(Math.pow(x - canvas.width / 2, 2) + Math.pow(y - canvas.height / 2, 2));
                speedX = Math.cos(angle + Math.PI / 2) * (particleBaseSpeed * 0.5) + (x - canvas.width / 2) * 0.001;
                speedY = Math.sin(angle + Math.PI / 2) * (particleBaseSpeed * 0.5) + (y - canvas.height / 2) * 0.001;
            } else if (currentParticleMovement === 'wave') {
                speedX = Math.sin(x * 0.05 + hue * 0.01) * particleBaseSpeed * 0.8;
                speedY = Math.cos(y * 0.05 + hue * 0.01) * particleBaseSpeed * 0.8;
            }

            particles.push({
                x: x,
                y: y,
                radius: radius,
                color: getParticleColor(),
                alpha: 1,
                speedX: speedX,
                speedY: speedY,
                life: particleLife
            });
            // Воспроизводим звук взаимодействия только в режиме свободной игры
            if (isPlaying && interactionSynth && gameMode === 'free-play') {
                interactionSynth.triggerAttackRelease("C5", "16n", Tone.now() + Math.random() * 0.01);
            }
        }

        // --- Настройки для аудио эффектов (мелодия) ---
        const notes = ["C3", "D3", "E3", "G3", "A3", "C4", "D4", "E4", "G4", "A4"];

        function createSynth(instrumentType) {
            // Не диспозируем здесь, так как синтезатор будет пересоздаваться в startAudioAndVisuals
            let newSynth;
            switch (instrumentType) {
                case 'simple-poly':
                    newSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "sine" },
                        envelope: { attack: 2, decay: 1, sustain: 0.5, release: 4 }
                    });
                    break;
                case 'fmsynth':
                    newSynth = new Tone.FMSynth({ 
                        harmonicity: 3.0,
                        modulationIndex: 10,
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 1.2 },
                        modulation: { type: "triangle" },
                        modulationEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.0, release: 0.5 }
                    });
                    break;
                case 'amsynth':
                    newSynth = new Tone.AMSynth({ 
                        harmonicity: 2.5,
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 1.2 },
                        modulation: { type: "square" },
                        modulationEnvelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.5 }
                    });
                    break;
                case 'pluck':
                    newSynth = new Tone.PluckSynth({ 
                        attackNoise: 1,
                        dampening: 4000,
                        resonance: 0.7
                    });
                    break;
                default:
                    newSynth = new Tone.PolySynth(Tone.Synth, { 
                        oscillator: { type: "sine" },
                        envelope: { attack: 2, decay: 1, sustain: 0.5, release: 4 }
                    });
            }
            return newSynth;
        }


        // Переменные для градиентного фона
        let bgHue1 = 0;
        let bgHue2 = 180;
        let bgLightness = 5; 

        // Функция для отрисовки динамического фона
        function drawDynamicBackground() {
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            const currentAudioLevelDB = audioAnalyzer && isPlaying ? audioAnalyzer.getLevel() : -60; 
            const normalizedLevel = Math.max(0, (currentAudioLevelDB + 60) / 60); 
            
            const minBgLightness = currentTheme === 'light' ? 80 : 5;
            const maxBgLightness = currentTheme === 'light' ? 95 : 20; 
            const dynamicLightness = minBgLightness + (normalizedLevel * (maxBgLightness - minBgLightness));

            gradient.addColorStop(0, `hsl(${bgHue1}, 50%, ${dynamicLightness}%)`);
            gradient.addColorStop(1, `hsl(${bgHue2}, 50%, ${dynamicLightness}%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            bgHue1 = (bgHue1 + 0.05) % 360;
            bgHue2 = (bgHue2 + 0.05) % 360;
        }

        // Функция для инициализации и запуска аудио и визуалов
        async function startAudioAndVisuals() {
            if (isPlaying) return; // Если уже играет, выходим

            try {
                await Tone.start(); // Запускаем аудио контекст
                console.log('Аудио контекст запущен!');

                // Инициализация эффектов и анализатора, если они еще не существуют
                if (!reverb) {
                    reverb = new Tone.Reverb({ decay: 8, preDelay: 0.2, wet: 0.6 }).toDestination();
                }
                if (!delay) {
                    delay = new Tone.FeedbackDelay({ delayTime: "4n", feedback: 0.5, wet: 0.3 }).connect(reverb);
                }
                if (!audioAnalyzer) {
                    audioAnalyzer = new Tone.Meter();
                }
                
                // Инициализация синтезаторов, если они еще не существуют
                if (!synth) {
                    synth = createSynth(currentInstrument);
                    synth.connect(delay); 
                    synth.connect(audioAnalyzer); 
                }
                synth.volume.value = parseFloat(volumeSlider.value); // Устанавливаем громкость

                if (!interactionSynth) {
                    interactionSynth = new Tone.PolySynth(Tone.Synth, { 
                        polyphony: 4, 
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                    interactionSynth.volume.value = -15;
                }

                if (!mazeSynth) {
                    mazeSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.5 }
                    }).toDestination();
                    mazeSynth.volume.value = -10;
                }

                // Инициализация последовательности лабиринта, если она еще не существует
                if (!mazeSequence) {
                    mazeSequence = new Tone.Sequence((time, note) => {
                        // Случайная нота из mazeNotes
                        const randomNote = mazeNotes[Math.floor(Math.random() * mazeNotes.length)];
                        mazeSynth.triggerAttackRelease(randomNote, "8n", time);
                    }, mazeNotes, "8n"); // mazeNotes здесь используется только для определения длины последовательности
                    mazeSequence.loop = true;
                }

                Tone.Transport.bpm.value = parseFloat(melodyTempoSlider.value);

                // Инициализация основного лупа, если он еще не существует
                if (!loop) {
                    loop = new Tone.Loop(time => {
                        // Мелодия играет только в режиме "Свободная игра"
                        if (gameMode === 'free-play') {
                            const numNotesToPlay = Math.random() < 0.5 ? 1 : 2;
                            const notesToPlay = [];
                            for (let i = 0; i < numNotesToPlay; i++) {
                                notesToPlay.push(notes[Math.floor(Math.random() * notes.length)]);
                            }
                            if (synth) { 
                                synth.triggerAttackRelease(notesToPlay, "2n", time);
                                synth.volume.rampTo(parseFloat(volumeSlider.value) + (Math.random() * 5 - 2.5), 2); 
                            }
                        }

                        particlePulseFactor = 1;
                        setTimeout(() => {
                            particlePulseFactor = 0;
                        }, 100);

                    }, "4n");
                }

                // Управление запуском/остановкой Tone.Transport и лупов в зависимости от режима
                if (gameMode === 'free-play') {
                    if (Tone.Transport.state !== 'started') {
                        Tone.Transport.start();
                    }
                    if (loop && loop.state !== 'started') {
                        loop.start(0);
                    }
                } else {
                    // Если не свободная игра, останавливаем основной луп
                    if (loop && loop.state === 'started') {
                        loop.stop();
                    }
                    // Транспорт должен оставаться запущенным для интерактивных синтезаторов (эхо, лабиринт)
                    if (Tone.Transport.state !== 'started') {
                        Tone.Transport.start();
                    }
                }

                isPlaying = true; // Устанавливаем флаг, что аудиосистема активна
                overlay.classList.add('hidden');
                menuToggleButton.classList.add('visible'); 
                updateGameInstructions(); // Обновляем инструкции при старте
            } catch (error) {
                console.error('Ошибка при запуске аудио:', error);
                alert(translations[currentLanguage].audioStartError);
            }
        }

        // Функция для смены инструмента
        function changeInstrument(newInstrumentType) {
            // Диспозиция старого синтезатора, если он существует
            if (synth && synth.dispose) {
                synth.disconnect();
                synth.dispose();
            }

            currentInstrument = newInstrumentType;
            synth = createSynth(currentInstrument); 
            
            // Подключение нового синтезатора к эффектам и анализатору
            if (delay) {
                synth.connect(delay);
            }
            if (audioAnalyzer) {
                synth.connect(audioAnalyzer);
            }
            
            synth.volume.value = parseFloat(volumeSlider.value);

            // Пересоздание и перезапуск лупа, если он был активен
            if (loop) {
                const wasLoopStarted = loop.state === 'started';
                loop.stop();
                loop.dispose();
                loop = null; // Обнуляем, чтобы он был пересоздан
                
                loop = new Tone.Loop(time => {
                    if (gameMode === 'free-play') {
                        const numNotesToPlay = Math.random() < 0.5 ? 1 : 2;
                        const notesToPlay = [];
                        for (let i = 0; i < numNotesToPlay; i++) {
                            notesToPlay.push(notes[Math.floor(Math.random() * notes.length)]);
                        }
                        if (synth) { 
                            synth.triggerAttackRelease(notesToPlay, "2n", time);
                            synth.volume.rampTo(parseFloat(volumeSlider.value) + (Math.random() * 5 - 2.5), 2);
                        }
                    }
                    particlePulseFactor = 1;
                    setTimeout(() => { particlePulseFactor = 0; }, 100);
                }, "4n");

                if (wasLoopStarted && Tone.Transport.state === 'started') {
                    loop.start(0);
                }
            }
        }

        // --- Обработчики для слайдеров и селектов ---
        volumeSlider.addEventListener('input', (e) => {
            if (synth) {
                synth.volume.value = parseFloat(e.target.value);
            }
        });

        particleMinSizeSlider.addEventListener('input', (e) => {
            particleMinSize = parseFloat(e.target.value);
            if (particleMinSize > particleMaxSize) {
                particleMaxSizeSlider.value = particleMinSize;
                particleMaxSize = particleMinSize;
            }
        });

        particleMaxSizeSlider.addEventListener('input', (e) => {
            particleMaxSize = parseFloat(e.target.value);
            if (particleMaxSize < particleMinSize) {
                particleMinSizeSlider.value = particleMaxSize;
                particleMinSize = particleMaxSize;
            }
        });

        particleLifeSlider.addEventListener('input', (e) => {
            particleLife = parseInt(e.target.value);
        });

        particleSpeedSlider.addEventListener('input', (e) => {
            particleBaseSpeed = parseFloat(e.target.value);
        });

        particleCountSlider.addEventListener('input', (e) => {
            maxParticles = parseInt(e.target.value);
        });

        particleSpawnRateSlider.addEventListener('input', (e) => {
            particleSpawnRate = parseInt(e.target.value);
        });

        melodyTempoSlider.addEventListener('input', (e) => {
            if (Tone.Transport) {
                Tone.Transport.bpm.value = parseFloat(e.target.value);
            }
        });

        colorPaletteSelect.addEventListener('change', (e) => {
            currentColorPalette = e.target.value;
        });

        particleShapeSelect.addEventListener('change', (e) => {
            currentParticleShape = e.target.value;
        });

        particleMovementSelect.addEventListener('change', (e) => {
            currentParticleMovement = e.target.value;
        });

        instrumentSelect.addEventListener('change', (e) => {
            changeInstrument(e.target.value);
        });

        clearCanvasButton.addEventListener('click', () => {
            particles = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawDynamicBackground();
        });

        screenshotButton.addEventListener('click', () => {
            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'zen_canvas_art.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        resetSettingsButton.addEventListener('click', () => {
            volumeSlider.value = defaultSettings.volume;
            particleMinSizeSlider.value = defaultSettings.particleMinSize;
            particleMaxSizeSlider.value = defaultSettings.particleMaxSize;
            particleLifeSlider.value = defaultSettings.particleLife;
            particleSpeedSlider.value = defaultSettings.particleSpeed;
            particleCountSlider.value = defaultSettings.particleCount;
            particleSpawnRateSlider.value = defaultSettings.particleSpawnRate;
            melodyTempoSlider.value = defaultSettings.melodyTempo;
            colorPaletteSelect.value = defaultSettings.colorPalette;
            particleShapeSelect.value = defaultSettings.particleShape;
            particleMovementSelect.value = defaultSettings.particleMovement;
            instrumentSelect.value = defaultSettings.instrument;
            gameModeSelect.value = defaultSettings.gameMode; // Сброс режима игры
            languageSelect.value = defaultSettings.language; // Сброс языка

            setTheme('dark');
            themeToggleButton.textContent = translations[currentLanguage].themeButtonLight; // Обновление текста кнопки темы

            gameMode = defaultSettings.gameMode; // Обновляем переменную режима игры
            setLanguage(defaultSettings.language); // Обновляем язык
            updateGameInstructions(); // Обновляем инструкции

            maxParticles = defaultSettings.particleCount;
            particleBaseSpeed = defaultSettings.particleSpeed;
            particleMinSize = defaultSettings.particleMinSize;
            particleMaxSize = defaultSettings.particleMaxSize;
            particleLife = defaultSettings.particleLife;
            particleSpawnRate = defaultSettings.particleSpawnRate;
            currentColorPalette = defaultSettings.colorPalette;
            currentParticleShape = defaultSettings.particleShape;
            currentParticleMovement = defaultSettings.particleMovement;
            
            // Диспозиция и пересоздание синтезаторов при сбросе
            if (synth) { synth.disconnect(); synth.dispose(); synth = null; }
            if (interactionSynth) { interactionSynth.disconnect(); interactionSynth.dispose(); interactionSynth = null; }
            if (mazeSynth) { mazeSynth.disconnect(); mazeSynth.dispose(); mazeSynth = null; }
            if (loop) { loop.stop(); loop.dispose(); loop = null; }
            if (mazeSequence) { mazeSequence.stop(); mazeSequence.dispose(); mazeSequence = null; }

            // Запускаем startAudioAndVisuals, чтобы переинициализировать аудиосистему
            // с настройками по умолчанию, если она была активна.
            isPlaying = false; // Сброс флага, чтобы startAudioAndVisuals запустилась
            startAudioAndVisuals(); // Перезапускаем аудиосистему

            isMazePlayingAudio = false;
            activeEchoSynthNote = null;

            // Генерируем новый лабиринт при сбросе настроек
            if (gameMode === 'melody-maze') {
                generateRandomMazePath();
            }

            bgHue1 = 0;
            bgHue2 = 180;

            clearCanvasButton.click();
        });


        // --- Обработчик для кнопки меню (ранее toggleControlsButton) ---
        menuToggleButton.addEventListener('click', () => {
            const isPanelVisible = controlsPanel.classList.contains('visible');
            if (isPanelVisible) {
                controlsPanel.classList.remove('visible');
                menuBackdrop.classList.remove('visible');
                menuToggleButton.textContent = translations[currentLanguage].menuButtonOpen;
            } else {
                controlsPanel.classList.add('visible');
                menuBackdrop.classList.add('visible');
                menuToggleButton.textContent = translations[currentLanguage].menuButtonClose; 
            }
        });

        // Обработчик для бэкдропа (закрывает меню при клике вне его)
        menuBackdrop.addEventListener('click', () => {
            controlsPanel.classList.remove('visible');
            menuBackdrop.classList.remove('visible');
            menuToggleButton.textContent = translations[currentLanguage].menuButtonOpen;
        });

        // --- Логика переключения темы ---
        function setTheme(theme) {
            currentTheme = theme;
            document.body.classList.toggle('light-theme', theme === 'light');
            canvas.style.backgroundColor = theme === 'light' ? '#e0e0e0' : '#000';
            ctx.fillStyle = theme === 'light' ? 'rgba(255, 255, 255, 0.03)' : 'rgba(0, 0, 0, 0.03)';
            localStorage.setItem('zenTheme', theme);
        }

        themeToggleButton.addEventListener('click', () => {
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
            themeToggleButton.textContent = newTheme === 'dark' ? translations[currentLanguage].themeButtonLight : translations[currentLanguage].themeButtonDark;
        });

        // --- Обработчик для выбора режима игры ---
        gameModeSelect.addEventListener('change', (e) => {
            gameMode = e.target.value;
            updateGameInstructions(); // Обновляем инструкции
            particles = []; // Очищаем частицы при смене режима

            // Останавливаем все активные аудио-компоненты
            if (loop && loop.state === 'started') {
                loop.stop();
            }
            if (mazeSequence && mazeSequence.state === 'started') {
                mazeSequence.stop();
                isMazePlayingAudio = false;
            }
            if (activeEchoSynthNote) {
                interactionSynth.triggerRelease(activeEchoSynthNote, Tone.now());
                activeEchoSynthNote = null;
            }

            // Убедимся, что Tone.Transport запущен, если мы в любом аудио-режиме
            if (Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }

            // Запускаем основной луп, если перешли в режим "Свободная игра"
            if (gameMode === 'free-play') {
                if (loop) loop.start(0);
            }

            // Генерируем новый лабиринт, если перешли в режим "Мелодичный лабиринт"
            if (gameMode === 'melody-maze') {
                generateRandomMazePath();
            }
        });

        // --- Обработчик для смены языка ---
        languageSelect.addEventListener('change', (e) => {
            setLanguage(e.target.value);
        });

        // --- Горячие клавиши ---
        document.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                clearCanvasButton.click();
            }
            if (e.key === 's' || e.key === 'S') {
                screenshotButton.click();
            }
            if (e.key === 'r' || e.key === 'R') {
                resetSettingsButton.click();
            }
            // "T" - Переключить меню
            if (e.key === 't' || e.key === 'T') {
                menuToggleButton.click();
            }
            // "L" - Переключить тему (Light/Dark)
            if (e.key === 'l' || e.key === 'L') {
                themeToggleButton.click();
            }
        });


        // --- Обработчики взаимодействия (обновлены для режимов игры) ---
        canvas.addEventListener('mousemove', (e) => {
            if (!isPlaying) return;
            if (gameMode === 'free-play') {
                for (let i = 0; i < particleSpawnRate; i++) {
                    createParticle(e.clientX, e.clientY);
                }
            } else if (gameMode === 'melody-maze') {
                const mousePos = { x: e.clientX, y: e.clientY };
                let onPath = false;

                for (let i = 0; i < currentMazePath.length - 1; i++) {
                    const p1 = currentMazePath[i];
                    const p2 = currentMazePath[i+1];
                    const distance = distToSegment(mousePos, p1, p2);
                    if (distance < mazeLineTolerance) {
                        onPath = true;
                        break;
                    }
                }

                if (onPath) {
                    if (!isMazePlayingAudio) {
                        // Tone.Transport уже запущен в gameModeSelect change
                        mazeSequence.start(Tone.now());
                        isMazePlayingAudio = true;
                    }
                    // Generate particles along the path
                    for (let i = 0; i < particleSpawnRate / 2; i++) { // Fewer particles to avoid clutter
                        createParticle(e.clientX, e.clientY);
                    }
                } else {
                    if (isMazePlayingAudio) {
                        mazeSequence.stop();
                        isMazePlayingAudio = false;
                    }
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isPlaying) return;
            if (gameMode === 'free-play') {
                for (let i = 0; i < e.touches.length; i++) {
                    for (let j = 0; j < particleSpawnRate; j++) {
                        createParticle(e.touches[i].clientX, e.touches[i].clientY);
                    }
                }
            } else if (gameMode === 'melody-maze') {
                const touchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                let onPath = false;

                for (let i = 0; i < currentMazePath.length - 1; i++) {
                    const p1 = currentMazePath[i];
                    const p2 = currentMazePath[i+1];
                    const distance = distToSegment(touchPos, p1, p2);
                    if (distance < mazeLineTolerance) {
                        onPath = true;
                        break;
                    }
                }

                if (onPath) {
                    if (!isMazePlayingAudio) {
                        // Tone.Transport уже запущен в gameModeSelect change
                        mazeSequence.start(Tone.now());
                        isMazePlayingAudio = true;
                    }
                    for (let i = 0; i < particleSpawnRate / 2; i++) {
                        createParticle(e.touches[0].clientX, e.touches[0].clientY);
                    }
                } else {
                    if (isMazePlayingAudio) {
                        mazeSequence.stop();
                        isMazePlayingAudio = false;
                    }
                }
            }
        }, { passive: false });

        // Обработчики mousedown/mouseup для режима "Эхо-сфера"
        canvas.addEventListener('mousedown', (e) => {
            if (!isPlaying) return;
            if (gameMode === 'echo-sphere') {
                if (activeEchoSynthNote) { // Если нота уже удерживается, отпускаем предыдущую
                    interactionSynth.triggerRelease(activeEchoSynthNote, Tone.now());
                }
                const normalizedY = e.clientY / canvas.height;
                const minFreq = Tone.Midi('C3').toFrequency();
                const maxFreq = Tone.Midi('C6').toFrequency();
                const frequency = minFreq + (maxFreq - minFreq) * (1 - normalizedY);
                activeEchoSynthNote = frequency;
                interactionSynth.triggerAttack(frequency, Tone.now());
                // Создаем начальный "всплеск" частиц для сферы
                for (let i = 0; i < 20; i++) { 
                    createParticle(e.clientX, e.clientY);
                }
            } else if (gameMode === 'melody-maze') {
                // В этом режиме mousedown/mouseup не управляют аудио напрямую,
                // только mousemove/touchmove. Однако, если пользователь кликнул вне пути,
                // нужно убедиться, что аудио остановилось.
                const mousePos = { x: e.clientX, y: e.clientY };
                let onPath = false;
                for (let i = 0; i < currentMazePath.length - 1; i++) {
                    const p1 = currentMazePath[i];
                    const p2 = currentMazePath[i+1];
                    const distance = distToSegment(mousePos, p1, p2);
                    if (distance < mazeLineTolerance) {
                        onPath = true;
                        break;
                    }
                }
                if (!onPath && isMazePlayingAudio) {
                    mazeSequence.stop();
                    isMazePlayingAudio = false;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameMode === 'echo-sphere') {
                if (activeEchoSynthNote) {
                    interactionSynth.triggerRelease(activeEchoSynthNote, Tone.now());
                    activeEchoSynthNote = null;
                }
            } else if (gameMode === 'melody-maze') {
                // При отпускании кнопки мыши в режиме лабиринта, останавливаем звук лабиринта
                if (isMazePlayingAudio) {
                    mazeSequence.stop();
                    isMazePlayingAudio = false;
                }
            }
        });

        // Обработчики touchstart/touchend для режима "Эхо-сфера"
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isPlaying) return;
            if (gameMode === 'echo-sphere') {
                if (activeEchoSynthNote) {
                    interactionSynth.triggerRelease(activeEchoSynthNote, Tone.now());
                }
                const normalizedY = e.touches[0].clientY / canvas.height;
                const minFreq = Tone.Midi('C3').toFrequency();
                const maxFreq = Tone.Midi('C6').toFrequency();
                const frequency = minFreq + (maxFreq - minFreq) * (1 - normalizedY);
                activeEchoSynthNote = frequency;
                interactionSynth.triggerAttack(frequency, Tone.now());
                for (let i = 0; i < 20; i++) {
                    createParticle(e.touches[0].clientX, e.touches[0].clientY);
                }
            } else if (gameMode === 'melody-maze') {
                const touchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                let onPath = false;
                for (let i = 0; i < currentMazePath.length - 1; i++) {
                    const p1 = currentMazePath[i];
                    const p2 = currentMazePath[i+1];
                    const distance = distToSegment(touchPos, p1, p2);
                    if (distance < mazeLineTolerance) {
                        onPath = true;
                        break;
                    }
                }
                if (!onPath && isMazePlayingAudio) {
                    mazeSequence.stop();
                    isMazePlayingAudio = false;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (gameMode === 'echo-sphere') {
                if (activeEchoSynthNote) {
                    interactionSynth.triggerRelease(activeEchoSynthNote, Tone.now());
                    activeEchoSynthNote = null;
                }
            } else if (gameMode === 'melody-maze') {
                // При отпускании пальца в режиме лабиринта, останавливаем звук лабиринта
                if (isMazePlayingAudio) {
                    mazeSequence.stop();
                    isMazePlayingAudio = false;
                }
            }
        }, { passive: false });


        // --- Основной цикл анимации для частиц и фона ---
        function animateParticles() {
            drawDynamicBackground();

            ctx.fillStyle = currentTheme === 'light' ? 'rgba(255, 255, 255, 0.03)' : 'rgba(0, 0, 0, 0.03)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Отрисовка пути лабиринта
            if (gameMode === 'melody-maze' && currentMazePath.length > 1) {
                ctx.beginPath();
                ctx.moveTo(currentMazePath[0].x, currentMazePath[0].y);
                for (let i = 1; i < currentMazePath.length; i++) {
                    ctx.lineTo(currentMazePath[i].x, currentMazePath[i].y);
                }
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)'; // Полупрозрачный синий
                ctx.lineWidth = 15; // Толщина линии
                ctx.lineCap = 'round'; // Скругленные концы линии
                ctx.lineJoin = 'round'; // Скругленные соединения
                ctx.stroke();
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                // Логика движения частиц в зависимости от режима игры
                if (gameMode === 'echo-sphere') {
                    const elapsed = Tone.now() - p.spawnTime;
                    // Радиальное расширение от начальной точки
                    const currentDistance = elapsed * particleBaseSpeed * 10; 
                    p.x = p.initialX + Math.cos(p.angle) * currentDistance;
                    p.y = p.initialY + Math.sin(p.angle) * currentDistance;
                    p.alpha -= 1 / p.life; 
                } else {
                    // Существующая логика движения для свободной игры и мелодичного лабиринта
                    if (currentParticleMovement === 'spiral') {
                        const angle = Math.atan2(p.y - canvas.height / 2, p.x - canvas.width / 2);
                        const distance = Math.sqrt(Math.pow(p.x - canvas.width / 2, 2) + Math.pow(p.y - canvas.height / 2, 2));
                        p.speedX = Math.cos(angle + Math.PI / 2) * (particleBaseSpeed * 0.5) + (p.x - canvas.width / 2) * 0.001;
                        p.speedY = Math.sin(angle + Math.PI / 2) * (particleBaseSpeed * 0.5) + (p.y - canvas.height / 2) * 0.001;
                    } else if (currentParticleMovement === 'wave') {
                        p.speedX = Math.sin(p.x * 0.05 + hue * 0.01) * particleBaseSpeed * 0.8;
                        p.speedY = Math.cos(p.y * 0.05 + hue * 0.01) * particleBaseSpeed * 0.8;
                    }
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.alpha -= 1 / p.life;
                }

                if (p.alpha <= 0 || p.life <= 0 || 
                    p.x < -p.radius || p.x > canvas.width + p.radius || 
                    p.y < -p.radius || p.y > canvas.height + p.radius) {
                    particles.splice(i, 1);
                    continue;
                }

                drawParticle(p);
            }

            while (particles.length > maxParticles) {
                particles.shift();
            }

            if (currentColorPalette === 'dynamic') {
                hue = (hue + 0.3) % 360;
            }

            requestAnimationFrame(animateParticles);
        }

        // Добавляем слушатель события на кнопку "Старт"
        startButton.addEventListener('click', startAudioAndVisuals);

        // Запускаем анимацию частиц и инициализируем аудио при загрузке
        window.onload = async function() { 
            const savedTheme = localStorage.getItem('zenTheme');
            if (savedTheme) {
                setTheme(savedTheme);
                themeToggleButton.textContent = translations[currentLanguage].themeButtonLight; // Обновляем текст кнопки темы
            } else {
                setTheme(defaultSettings.theme);
                themeToggleButton.textContent = translations[currentLanguage].themeButtonLight;
            }

            const savedLanguage = localStorage.getItem('zenLanguage');
            if (savedLanguage && translations[savedLanguage]) {
                languageSelect.value = savedLanguage;
                setLanguage(savedLanguage);
            } else {
                languageSelect.value = defaultSettings.language;
                setLanguage(defaultSettings.language);
            }


            bgHue1 = Math.random() * 360;
            bgHue2 = (bgHue1 + 180) % 360;

            // Инициализируем лабиринт после установки размеров холста
            resizeCanvas(); // Устанавливаем размеры холста
            generateRandomMazePath(); // Генерируем начальный лабиринт

            animateParticles();
            updateGameInstructions();
        };
    </script>
</body>
</html>
